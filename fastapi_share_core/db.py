import asyncio
import configparser
import re
import time
from typing import Generator, Annotated

import sqlalchemy as sa
from loguru import logger
from alembic import config, command
from alembic.util.exc import AutogenerateDiffsDetected
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from pathlib import Path
from fastapi import Depends
from fastapi_share_core.config import core_settings
from fastapi_share_core.exception import ConfigException
from fastapi_share_core.utils import get_s_timestamp

engine = create_async_engine(
    core_settings.sqlalchemy_uri,
    pool_size=core_settings.db_pool_size,
    max_overflow=core_settings.db_max_overflow,
    echo=core_settings.db_echo,
    pool_pre_ping=core_settings.db_pool_pre_ping,
    pool_recycle=core_settings.db_pool_recycle,
)

session_factory = async_sessionmaker(engine, expire_on_commit=False)


async def get_db() -> Generator[AsyncSession, None, None]:
    async with session_factory() as session:
        try:
            yield session
            await session.commit()
        except Exception as e:
            await session.rollback()
            raise e
        finally:
            await session.close()
            logger.debug("会话关闭")


AsyncSessionDep = Annotated[AsyncSession, Depends(get_db)]


class Base(DeclarativeBase):
    id: Mapped[int] = mapped_column(primary_key=True, comment="自增ID")
    created_at: Mapped[int] = mapped_column(default=get_s_timestamp, comment="创建时间")
    updated_at: Mapped[int] = mapped_column(
        default=get_s_timestamp, onupdate=get_s_timestamp, comment="更新时间"
    )


async def _check_database_exist():
    """检查数据库是否创建"""
    _engine = create_async_engine(
        core_settings.sqlalchemy_uri_without_db,
        pool_size=core_settings.db_pool_size,
        max_overflow=core_settings.db_max_overflow,
        echo=core_settings.db_echo,
        pool_pre_ping=core_settings.db_pool_pre_ping,
        pool_recycle=core_settings.db_pool_recycle,
    )

    async with _engine.connect() as conn:
        res = await conn.execute(sa.text("SHOW DATABASES"))
        dbs = res.scalars().all()
        if core_settings.db_name not in dbs:
            logger.info(f"检测到未创建数据库{core_settings.db_name}，3秒后将自动创建")
            await asyncio.sleep(3)
            await conn.execute(
                sa.text(
                    "CREATE DATABASE `:db_name`"
                    " DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;"
                ),
                {"db_name": core_settings.db_name},
            )
            logger.info(f"已成功创建数据库{core_settings.db_name}")


def _update_alembic_ini():
    # 修改alembic.ini配置文件
    parser = configparser.ConfigParser()
    parser.read(core_settings.db_alembic_cfg_filename)
    parser.set("alembic", "script_location", core_settings.db_alembic_script_location)
    sqlalchemy_url = core_settings.sqlalchemy_uri.render_as_string(hide_password=False)
    parser.set("alembic", "sqlalchemy.url", sqlalchemy_url)
    with open(core_settings.db_alembic_cfg_filename, "w") as f:
        parser.write(f)


def _update_alembic_env():
    """更新 alembic env.py 中的 metadata 配置"""
    env_path = f"{core_settings.db_alembic_script_location}/env.py"

    # 读取文件内容
    with open(env_path, "r") as file:
        content = file.read()

    # 定义要替换的模式
    pattern = r"target_metadata = None"

    # 新的配置内容
    replacement = (
        "from fastapi_share_core.db import Base\ntarget_metadata = Base.metadata"
    )

    # 执行替换
    new_content = re.sub(pattern, replacement, content)

    # 写回文件
    with open(env_path, "w") as file:
        file.write(new_content)


def _check_alembic_init():
    """检查alembic是否初始化"""
    # 检查alembic是否初始化
    if not (
        Path(core_settings.db_alembic_script_location).is_dir()
        or Path(core_settings.db_alembic_cfg_filename).is_file()
    ):
        logger.info("检测到alembic还未初始化，3秒后将自动初始化")
        time.sleep(3)
        alembic_cfg = config.Config(core_settings.db_alembic_cfg_filename)

        command.init(alembic_cfg, core_settings.db_alembic_script_location, "async")

        _update_alembic_ini()
        _update_alembic_env()
        logger.info("alembic 已成功初始化")


def _sync_db_and_orm():
    logger.info("正在检测数据表与ORM的一致性")
    alembic_cfg = config.Config(core_settings.db_alembic_cfg_filename)
    command.upgrade(alembic_cfg, "head")

    try:
        command.check(alembic_cfg)
    except AutogenerateDiffsDetected:
        logger.info("数据表和ORM存在差异，3秒后将自动生成迁移文件")
        time.sleep(3)
        command.revision(alembic_cfg, autogenerate=True)

    command.upgrade(alembic_cfg, "head")
    logger.info("迁移完成，数据表与ORM已保持一致")


async def _drop_alembic_version():
    async with engine.connect() as conn:
        await conn.execute(sa.text("DROP TABLE IF EXISTS alembic_version;"))


async def create_all_tables():
    async with engine.connect() as conn:
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)


def check_db():
    if any(
        [
            core_settings.db_host is None,
            core_settings.db_port is None,
            core_settings.db_username is None,
            core_settings.db_password is None,
            core_settings.db_name is None,
        ]
    ):
        raise ConfigException("请检查数据库配置")

    asyncio.run(_check_database_exist())
    _check_alembic_init()
    if core_settings.env == "production":
        _sync_db_and_orm()
    elif core_settings.env == "test":
        asyncio.run(_drop_alembic_version())
        _sync_db_and_orm()
    else:
        asyncio.run(create_all_tables())
